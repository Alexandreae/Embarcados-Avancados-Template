{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Conformance Tester for TAGs EPC-GEN2 UHF RFID \u00b6 Students: Alexandre Almeida Edington / Bruno Signorelli Domingues / Lucas Leal Vale / Rafael Dos Santos Course: Computer Engineering Semester: 8 Teacher: Rafael Corsi Ferr\u00e3o Contact: alexandreae@al.insper.edu.br brunosd1@al.insper.edu.br lucaslv1@al.insper.edu.br rafaels6@al.insper.edu.br rafael.corsi@insper.edu.br Year: 2021 Repository: https://github.com/pfeinsper/21b-indago-rfid-conformance-tester About \u00b6 This project aims to develop an equipment capable of performing a series of tests on RFID TAGs, based on the communication protocol \"EPC-GEN2 UHF RFID\" 1 . The project simplifies the development of new TAGs that conform to the defined protocol, being able to assert whether the tag satisfies the requirements of said protocol, and also whether the TAG itself is working as intended. Insper \u00b6 This project is being developed by four computer engineering students at \"Insper Instituto de Ensino e Pesquisa\" 2 , together with \"Indago Services Inc.\" 3 . As part of their completion of course work, the students must communicate with their selected company to identify a problem the company currently has and work together to find and implement a solution to it. For each group of students there is also a teaches that acts as a mentor and aids the group with matters of communication, organization, meetings, and project and report feedbacks. Indago Devices Inc. \u00b6 Indago Devices Inc. is a startup that has its headquarters in the city of Birmingham Alabama, US, and works in the field of development and study of electronics. Despite having few employees, it seeks to innovate in the electronics market, specifically in the development of systems that communicate through RFID. They had already been communicating with Insper in the previous semester, and another group of students who planned to do a similar project. This semester they decided to request a conformance tester to help develop RFID TAGs. One of the driving points of the project is that currently there is no similar software available on open source for the RFID community, so it could impact not only their company, but also the worldwide RFID development community. Project Overview \u00b6 The main objective of this project is to develop and assemble a conformance tester for RFID TAGs where a microcontroller will be implemented and an IP-Rfid for communication with the DUT (device under testing). This device then shall be able to run a series of tests as a READER interacting with a TAG through the EPC-GEN2 protocol, analyzing if the TAG works as intended and complies with the requirements of the protocol. The tests will be implemented using C, allowing for a large number of tests to be made that target different aspects of the TAG's process, independently evaluating most of them. Also, it will be possible to customize the tests or develop new ones should the user need to do so. This project does not make use of RFID communication, nor does it intend to test whether the TAG is able to communicate through it. Given the complexity of communicating through radio waves, the group and the teacher agreed to not cover those points in this project. Therefore, the device, TAG and computer shall be connected by cables. Protocol EPC-GEN2 UHF RFID \u00b6 Documentation avaliable on: https://www.gs1.org/sites/default/files/docs/epc/Gen2_Protocol_Standard.pdf The main purpose of the protocol is to allow two pieces of hardware, obtained independently, but conforming to the protocol, to communicate flawlessly. To achieve this, it specifies how physical and logical interactions should take place, as well as the possible commands between READER and TAG. To claim compliance with the protocol, a READER must meet all required specifications, having implemented all mandatory commands, be able to encode, send, receive, and decode data so that it can communicate with a TAG, as well as comply with all local government radio regulations. Optionally, it is allowed to implement any number of optional commands defined in the protocol and any other private commands that do not conflict with any of the mandatory ones. Finally, a READER must not require a TAG to be able to process any command that is not specified as mandatory in the protocol. To claim compliance with the protocol, a TAG must meet all required specifications, having implemented all mandatory commands, be able to modulate a response signal after receiving a command from a READER, and comply with all local government radio regulations. Optionally, it is allowed to implement any number of optional commands defined in the protocol and any other private commands that do not conflict with any of the mandatory ones. Finally, the TAG must not require a READER to be able to process any optional command from the protocol and is not allowed to modulate a response signal unless it has been commanded to do so by a READER using the commands present in the protocol. The EPC-GEN2 UHF RFID allow four types of commands in its documentation: 1- mandatory; 2- optional; 3- proprietary; 4- custom. All commands defined in the protocol are either mandatory or optional. Proprietary and custom commands are manufacturer-defined. Mandatory commands shall be supported by all TAGs and READERs that claim compliance to the protocol. Optional commands may or may not be supported by TAGs or READERs. If any implements optional commands, then it shall do so in the manner specified in the protocol. Proprietary commands may be enabled in conformance with the protocol but are not specified in it. All proprietary commands shall be capable of being permanently disabled. Proprietary commands are intended for manufacturing purposes and shall not be used in field-deployed RFID systems. Custom commands may be enabled in conformance with the protocol but are not specified in it. A READER shall issue a custom command only after singulating a TAG and reading (or having prior knowledge of) the TAG manufacturer\u2019s identification in the TAG\u2019s TID memory. A READER shall use a custom command only in accordance with the specifications of the TAG manufacturer identified in the TID. A custom command shall not solely duplicate the functionality of any mandatory or optional command defined in the protocol by a different method. Mandatory Commands Select selects the population of TAGs that will be communicated with. The set can be defined by intersection, union or negation of TAGs; Query / Query Adjust / Query Rep starts a communication round between the TAGs and READER, deciding which TAG will participate in the round and sending the Q value for such. Query Adjust can adjust que Q value for the TAG. Query Rep decreases the value of Q stored within the TAG\u2019s memory by 1; ACK / NAK is sent to the TAG with the same value sent by the TAG when returning to the Query command. It signifies the READER recognized the TAG\u2019s response. NAK changes the state of the TAGs involved in the round to arbitrate , in which they remain as stand-by; Req_RN requests a new random number (RN16), sending the previous one as authentication; Read / Write requests the reading of information within a specified address in the TAG\u2019s memory bank. Write sends information to be written in that address instead; Kill / Lock sets the tag as unusable. It is a way to end the communication so that the TAG no longer responds. Lock can lock or unlock portions of the TAG\u2019s memory bank for Write access. Handshake The diagram below can be found in annex E of the EPC-GEN2 documentation and represents the Hand-shake between READER and TAG. The READER sends a Query (1), to start an inventory round with the TAG. Upon recognizing the inventory round, the TAG checks whether to respond, and responds with a 16-bit random number RN16 (2). To establish the communication as successful, the reader sends the ACK (3) containing the same RN16. Having received and validated the confirmation, the TAG responds with PC/XPC, EPC (4). The reader then send a Req_RN (5), again with the old RN16, requesting a new RN16 to continue the communication. If the TAG again validates the RN16, it responds with the handle (6), a new RN16. Once the READER receives the handle , the handshake is effectively over and the handle will be used as authentication for all communication from that point forwards. Every command (7) will be sent together with the handle and TAG will always verify the handle before responding (8). State-of-the-Art Review \u00b6 The market currently has very diversified solutions in relation to RFID technology. Among the options currently available, proprietary equipment and products are the main competitors, as they are developed by well-established companies. For example, CISC semiconductor 4 , specializing in RFID and NFC services, and working both in the production of laboratory equipment and product testers for the market. Another company that is worth mentioning is HID global 5 , which has several solutions for RFID tags end operates worldwide under sales and distribution of these products. There are, however, other solutions present in the market, such as open-source solutions. As proprietary products are expensive and not easily customizable, some users choose to develop their own version of those products, leaving them open for others to use and improve. The use of open source helps to develop a highly customizable product, as every user can download the program and make their own changes to better suit their need. Another benefit of open source is the collaboration aspect, where users around the world can suggest changes or improvements, as well as implement them to improve the overall product. An example of an open-source product is the WISP5 6 tag, initially developed at the University of Washington 7 . The WISP is a battery-free platform with a software-defined implementation of a passive RFID tag, that can communicate with commercial-off-the-shelf RFID readers and is powered by the carrier signal emitted by the reader. It is also built from low-cost components commonly found in hardware stores, allowing WISP users to fabricate their own platforms if desired. Another open-source product is the S.U.R.F.E.R. (Software-defined UHF RFID Flexible Economical Reader) 8 , an RFID reader. It operates with the same technology as the WISP5 tag, enabling readings up to 60 feet (20 meters) away. Due to it being software-defined, the reader is highly versatile, as the user can input the specifications of the desired tag into the software. It also has a relatively simple structure to find, which result in a low-cost product. Open-source products bring a series of benefits to the users, such as lesser hardware and software costs, due to the products being intentionally built to be easily accessible; simple licensing management because they often are free to use and impose no restrictions at all; abundant support, as there are many companies that develop open-source products and offer both free and varied levels of paid support. Given these advantages, Indago Devices opted for a completely open-source product as well. In a meeting with our mentor Wallace Shepherd Pitts, he mentioned he had previously researched and studied some of the options currently available, but nothing had fit with what he had in mind, because the products offered little room for customization regarding the tests made to the tag. The direct competitors of our project would be the previously mentioned products, which dominate the current market. However, as we are aiming for the open-source architecture, it may attract users interested in a more accessible or customizable product. Another point mentioned by our mentor is that he also intends to use the project as study material for students at the University of North Carolina 9 , which consequently opens up possibilities for further expansion of the product. Methodology \u00b6 During the first weeks of the project, the group settled on definitions and agreements on what would be the methodology used throughout the semester, as well as the different tools and softwares that would be used. The platform GitHub was chosen as the method for sharing the code between the group members and the teacher, as it can store many important files other than code files, such as diagrams and images the group would produce for the project. Another feature often used by the group is the creation of issues, which can help define and order the group\u2019s next tasks and assign members to complete them. The day-to-day communication between the members were done through Discord, and meetings with Indago\u2019s representative or the PFE\u2019s coordinators though Microsoft Teams. As meetings with a member of the company were infrequent, taking place every fortnight, the group usually kept a list of questions and issues about the EPC-GEN2 protocol and the project in general so that the representative could provide some support. Documents and reports were produced and stored in Google Drive, so that multiple members could work on them simultaneously, and also be accessed by the teacher to provide insights and feedback. It also served as another backup storage to the Github repository, in case any problems occurred. The programming languages VHDL and C were used throughout the project, through the softwares Quartus and Eclipse, which support simulations and tests that aid in the development process. As the client specified that he wanted the project to be open-source, all code, reports and images relevant to this will also be available on the project\u2019s public GitHub repository. As the project consists of the creation of a conformance tester for the EPC-GEN2 UHF RFID protocol, its documentation was widely used, researched, and discussed by all members of the group during the project, focusing mainly on the communication sections between the READER and TAG, as well as encoding data, and mandatory commands for protocol standards. Since the project was open-source and available on GitHub, it was decided that the group would also provide a documentation to the whole project, which was later decided would be available through GitHub Pages. Inside, the group would give an in-depth description of all components, and also a tutorial on how to clone, run, utilize and modify this project. Tools \u00b6 Development Tools \u00b6 Intel\u00ae Quartus\u00ae Prime FPGA Design Software Eclipse IDE 2021\u201109 Intel\u00ae FPGA Simulation - ModelSim Github.com Design Tools \u00b6 Google Drive Excalidraw.com Discord EPC UHF Gen2 Air Interface Protocol. https://www.gs1.org/sites/default/files/docs/epc/Gen2_Protocol_Standard.pdf Accessed on: 16/08/2021. \u21a9 Insper Instituto de Ensino e Pesquisa. https://www.insper.edu.br/ Accessed on: 16/08/2021. \u21a9 Indago Devices Inc.. https://indagodevices.com Accessed on: 16/08/2021. \u21a9 Cisc Semiconductors. https://www.cisc.at/ Accessed on: 20/09/2021. \u21a9 HID Global. https://www.hidglobal.com/products/rfid-tags Accessed on: 20/09/2021. \u21a9 WISP5 Wiki. https://sites.google.com/uw.edu/WISP-wiki/home Accessed on: 20/09/2021. \u21a9 University of Washington. https://www.washington.edu/ Accessed on: 20/09/2021. \u21a9 S.U.R.F.E.R. reader. https://openrfidreader.net/ Accessed on: 20/09/2021. \u21a9 University of North Carolina. https://www.uncg.edu/ Accessed on: 20/09/2021. \u21a9","title":"Home"},{"location":"#conformance-tester-for-tags-epc-gen2-uhf-rfid","text":"Students: Alexandre Almeida Edington / Bruno Signorelli Domingues / Lucas Leal Vale / Rafael Dos Santos Course: Computer Engineering Semester: 8 Teacher: Rafael Corsi Ferr\u00e3o Contact: alexandreae@al.insper.edu.br brunosd1@al.insper.edu.br lucaslv1@al.insper.edu.br rafaels6@al.insper.edu.br rafael.corsi@insper.edu.br Year: 2021 Repository: https://github.com/pfeinsper/21b-indago-rfid-conformance-tester","title":"Conformance Tester for TAGs EPC-GEN2 UHF RFID"},{"location":"#about","text":"This project aims to develop an equipment capable of performing a series of tests on RFID TAGs, based on the communication protocol \"EPC-GEN2 UHF RFID\" 1 . The project simplifies the development of new TAGs that conform to the defined protocol, being able to assert whether the tag satisfies the requirements of said protocol, and also whether the TAG itself is working as intended.","title":"About"},{"location":"#insper","text":"This project is being developed by four computer engineering students at \"Insper Instituto de Ensino e Pesquisa\" 2 , together with \"Indago Services Inc.\" 3 . As part of their completion of course work, the students must communicate with their selected company to identify a problem the company currently has and work together to find and implement a solution to it. For each group of students there is also a teaches that acts as a mentor and aids the group with matters of communication, organization, meetings, and project and report feedbacks.","title":"Insper"},{"location":"#indago-devices-inc","text":"Indago Devices Inc. is a startup that has its headquarters in the city of Birmingham Alabama, US, and works in the field of development and study of electronics. Despite having few employees, it seeks to innovate in the electronics market, specifically in the development of systems that communicate through RFID. They had already been communicating with Insper in the previous semester, and another group of students who planned to do a similar project. This semester they decided to request a conformance tester to help develop RFID TAGs. One of the driving points of the project is that currently there is no similar software available on open source for the RFID community, so it could impact not only their company, but also the worldwide RFID development community.","title":"Indago Devices Inc."},{"location":"#project-overview","text":"The main objective of this project is to develop and assemble a conformance tester for RFID TAGs where a microcontroller will be implemented and an IP-Rfid for communication with the DUT (device under testing). This device then shall be able to run a series of tests as a READER interacting with a TAG through the EPC-GEN2 protocol, analyzing if the TAG works as intended and complies with the requirements of the protocol. The tests will be implemented using C, allowing for a large number of tests to be made that target different aspects of the TAG's process, independently evaluating most of them. Also, it will be possible to customize the tests or develop new ones should the user need to do so. This project does not make use of RFID communication, nor does it intend to test whether the TAG is able to communicate through it. Given the complexity of communicating through radio waves, the group and the teacher agreed to not cover those points in this project. Therefore, the device, TAG and computer shall be connected by cables.","title":"Project Overview"},{"location":"#protocol-epc-gen2-uhf-rfid","text":"Documentation avaliable on: https://www.gs1.org/sites/default/files/docs/epc/Gen2_Protocol_Standard.pdf The main purpose of the protocol is to allow two pieces of hardware, obtained independently, but conforming to the protocol, to communicate flawlessly. To achieve this, it specifies how physical and logical interactions should take place, as well as the possible commands between READER and TAG. To claim compliance with the protocol, a READER must meet all required specifications, having implemented all mandatory commands, be able to encode, send, receive, and decode data so that it can communicate with a TAG, as well as comply with all local government radio regulations. Optionally, it is allowed to implement any number of optional commands defined in the protocol and any other private commands that do not conflict with any of the mandatory ones. Finally, a READER must not require a TAG to be able to process any command that is not specified as mandatory in the protocol. To claim compliance with the protocol, a TAG must meet all required specifications, having implemented all mandatory commands, be able to modulate a response signal after receiving a command from a READER, and comply with all local government radio regulations. Optionally, it is allowed to implement any number of optional commands defined in the protocol and any other private commands that do not conflict with any of the mandatory ones. Finally, the TAG must not require a READER to be able to process any optional command from the protocol and is not allowed to modulate a response signal unless it has been commanded to do so by a READER using the commands present in the protocol. The EPC-GEN2 UHF RFID allow four types of commands in its documentation: 1- mandatory; 2- optional; 3- proprietary; 4- custom. All commands defined in the protocol are either mandatory or optional. Proprietary and custom commands are manufacturer-defined. Mandatory commands shall be supported by all TAGs and READERs that claim compliance to the protocol. Optional commands may or may not be supported by TAGs or READERs. If any implements optional commands, then it shall do so in the manner specified in the protocol. Proprietary commands may be enabled in conformance with the protocol but are not specified in it. All proprietary commands shall be capable of being permanently disabled. Proprietary commands are intended for manufacturing purposes and shall not be used in field-deployed RFID systems. Custom commands may be enabled in conformance with the protocol but are not specified in it. A READER shall issue a custom command only after singulating a TAG and reading (or having prior knowledge of) the TAG manufacturer\u2019s identification in the TAG\u2019s TID memory. A READER shall use a custom command only in accordance with the specifications of the TAG manufacturer identified in the TID. A custom command shall not solely duplicate the functionality of any mandatory or optional command defined in the protocol by a different method. Mandatory Commands Select selects the population of TAGs that will be communicated with. The set can be defined by intersection, union or negation of TAGs; Query / Query Adjust / Query Rep starts a communication round between the TAGs and READER, deciding which TAG will participate in the round and sending the Q value for such. Query Adjust can adjust que Q value for the TAG. Query Rep decreases the value of Q stored within the TAG\u2019s memory by 1; ACK / NAK is sent to the TAG with the same value sent by the TAG when returning to the Query command. It signifies the READER recognized the TAG\u2019s response. NAK changes the state of the TAGs involved in the round to arbitrate , in which they remain as stand-by; Req_RN requests a new random number (RN16), sending the previous one as authentication; Read / Write requests the reading of information within a specified address in the TAG\u2019s memory bank. Write sends information to be written in that address instead; Kill / Lock sets the tag as unusable. It is a way to end the communication so that the TAG no longer responds. Lock can lock or unlock portions of the TAG\u2019s memory bank for Write access. Handshake The diagram below can be found in annex E of the EPC-GEN2 documentation and represents the Hand-shake between READER and TAG. The READER sends a Query (1), to start an inventory round with the TAG. Upon recognizing the inventory round, the TAG checks whether to respond, and responds with a 16-bit random number RN16 (2). To establish the communication as successful, the reader sends the ACK (3) containing the same RN16. Having received and validated the confirmation, the TAG responds with PC/XPC, EPC (4). The reader then send a Req_RN (5), again with the old RN16, requesting a new RN16 to continue the communication. If the TAG again validates the RN16, it responds with the handle (6), a new RN16. Once the READER receives the handle , the handshake is effectively over and the handle will be used as authentication for all communication from that point forwards. Every command (7) will be sent together with the handle and TAG will always verify the handle before responding (8).","title":"Protocol EPC-GEN2 UHF RFID"},{"location":"#state-of-the-art-review","text":"The market currently has very diversified solutions in relation to RFID technology. Among the options currently available, proprietary equipment and products are the main competitors, as they are developed by well-established companies. For example, CISC semiconductor 4 , specializing in RFID and NFC services, and working both in the production of laboratory equipment and product testers for the market. Another company that is worth mentioning is HID global 5 , which has several solutions for RFID tags end operates worldwide under sales and distribution of these products. There are, however, other solutions present in the market, such as open-source solutions. As proprietary products are expensive and not easily customizable, some users choose to develop their own version of those products, leaving them open for others to use and improve. The use of open source helps to develop a highly customizable product, as every user can download the program and make their own changes to better suit their need. Another benefit of open source is the collaboration aspect, where users around the world can suggest changes or improvements, as well as implement them to improve the overall product. An example of an open-source product is the WISP5 6 tag, initially developed at the University of Washington 7 . The WISP is a battery-free platform with a software-defined implementation of a passive RFID tag, that can communicate with commercial-off-the-shelf RFID readers and is powered by the carrier signal emitted by the reader. It is also built from low-cost components commonly found in hardware stores, allowing WISP users to fabricate their own platforms if desired. Another open-source product is the S.U.R.F.E.R. (Software-defined UHF RFID Flexible Economical Reader) 8 , an RFID reader. It operates with the same technology as the WISP5 tag, enabling readings up to 60 feet (20 meters) away. Due to it being software-defined, the reader is highly versatile, as the user can input the specifications of the desired tag into the software. It also has a relatively simple structure to find, which result in a low-cost product. Open-source products bring a series of benefits to the users, such as lesser hardware and software costs, due to the products being intentionally built to be easily accessible; simple licensing management because they often are free to use and impose no restrictions at all; abundant support, as there are many companies that develop open-source products and offer both free and varied levels of paid support. Given these advantages, Indago Devices opted for a completely open-source product as well. In a meeting with our mentor Wallace Shepherd Pitts, he mentioned he had previously researched and studied some of the options currently available, but nothing had fit with what he had in mind, because the products offered little room for customization regarding the tests made to the tag. The direct competitors of our project would be the previously mentioned products, which dominate the current market. However, as we are aiming for the open-source architecture, it may attract users interested in a more accessible or customizable product. Another point mentioned by our mentor is that he also intends to use the project as study material for students at the University of North Carolina 9 , which consequently opens up possibilities for further expansion of the product.","title":"State-of-the-Art Review"},{"location":"#methodology","text":"During the first weeks of the project, the group settled on definitions and agreements on what would be the methodology used throughout the semester, as well as the different tools and softwares that would be used. The platform GitHub was chosen as the method for sharing the code between the group members and the teacher, as it can store many important files other than code files, such as diagrams and images the group would produce for the project. Another feature often used by the group is the creation of issues, which can help define and order the group\u2019s next tasks and assign members to complete them. The day-to-day communication between the members were done through Discord, and meetings with Indago\u2019s representative or the PFE\u2019s coordinators though Microsoft Teams. As meetings with a member of the company were infrequent, taking place every fortnight, the group usually kept a list of questions and issues about the EPC-GEN2 protocol and the project in general so that the representative could provide some support. Documents and reports were produced and stored in Google Drive, so that multiple members could work on them simultaneously, and also be accessed by the teacher to provide insights and feedback. It also served as another backup storage to the Github repository, in case any problems occurred. The programming languages VHDL and C were used throughout the project, through the softwares Quartus and Eclipse, which support simulations and tests that aid in the development process. As the client specified that he wanted the project to be open-source, all code, reports and images relevant to this will also be available on the project\u2019s public GitHub repository. As the project consists of the creation of a conformance tester for the EPC-GEN2 UHF RFID protocol, its documentation was widely used, researched, and discussed by all members of the group during the project, focusing mainly on the communication sections between the READER and TAG, as well as encoding data, and mandatory commands for protocol standards. Since the project was open-source and available on GitHub, it was decided that the group would also provide a documentation to the whole project, which was later decided would be available through GitHub Pages. Inside, the group would give an in-depth description of all components, and also a tutorial on how to clone, run, utilize and modify this project.","title":"Methodology"},{"location":"#tools","text":"","title":"Tools"},{"location":"#development-tools","text":"Intel\u00ae Quartus\u00ae Prime FPGA Design Software Eclipse IDE 2021\u201109 Intel\u00ae FPGA Simulation - ModelSim Github.com","title":"Development Tools"},{"location":"#design-tools","text":"Google Drive Excalidraw.com Discord EPC UHF Gen2 Air Interface Protocol. https://www.gs1.org/sites/default/files/docs/epc/Gen2_Protocol_Standard.pdf Accessed on: 16/08/2021. \u21a9 Insper Instituto de Ensino e Pesquisa. https://www.insper.edu.br/ Accessed on: 16/08/2021. \u21a9 Indago Devices Inc.. https://indagodevices.com Accessed on: 16/08/2021. \u21a9 Cisc Semiconductors. https://www.cisc.at/ Accessed on: 20/09/2021. \u21a9 HID Global. https://www.hidglobal.com/products/rfid-tags Accessed on: 20/09/2021. \u21a9 WISP5 Wiki. https://sites.google.com/uw.edu/WISP-wiki/home Accessed on: 20/09/2021. \u21a9 University of Washington. https://www.washington.edu/ Accessed on: 20/09/2021. \u21a9 S.U.R.F.E.R. reader. https://openrfidreader.net/ Accessed on: 20/09/2021. \u21a9 University of North Carolina. https://www.uncg.edu/ Accessed on: 20/09/2021. \u21a9","title":"Design Tools"},{"location":"firmware/","text":"Firmware \u00b6 Below is an in depth explanation of the mechanism responsible for the communication between the NIOS II processor and the IP Core, which is composed by the Avalon Interface and a register bank that connect the other components. Avalon Interface \u00b6 The Avalon Interface, according to its developer Intel (in \u201cAvalon\u00ae Interface Specifications\u201d, 2021, p.4): \"Avalon\u00ae interfaces simplify system design by allowing you to easily connect components in Intel\u00ae FPGA. The Avalon interface family defines interfaces appropriate for streaming high-speed data, reading, and writing registers and memory, and controlling off-chip devices. Components available in Platform Designer incorporate these standard interfaces. Additionally, you can incorporate Avalon interfaces in custom components, enhancing the interoperability of designs.\". In other words, it is possible to conclude from this excerpt that, in addition to enabling the connection between Intel\u00ae FPGA components, that once the interfaces are added to Platform Designer, they can connect custom components, which we use for the IP-Rfid in our product. All documentation for other possible interfaces and connection is present in the document \u201cAvalon\u00ae Interface Specifications\u201d. The Avalon Bus can be implemented with multiple features and modules. In this project, Avalon Memory-Mapped will be used, but other alternatives were considered, such as Avalon Interrupt Interfaces and Avalon Streaming Interfaces. The Avalon Memory-Mapped (Avalon-MM) interface implements the writing and reading of interfaces for the other components used, including Memory, UART Chip and the NIOS II. The interface uses a Host and Agent system in which the Host is the provider of data and commands to the Agent, while the Agent responds to the Host. These relations can be viewed in the images below, which represent an example of Host and Agent communication in the first image, and an example of writing to an address in the second one. Register Bank \u00b6 The register bank intermediates the communication between the NIOS II processor and the IP Core. Each access to the bus is done through a read or write command in which they carry data up to 32 bits, a value that represents the size of an integer in the programming language C, as it is the one implemented in the processor. As seen in the table, this communication path is responsible for the IP peripheral settings, informing essential values for communication such as Tari , Delimiter and Status , as well as others shown below. offset Name Access Size (bits) 0 REG_Settings Read/Write 32 1 REG_Tari Read/Write 16 2 REG_FIFO Write 32 3 REG_Tari_101 Write 16 4 REG_Tari_099 Write 16 5 REG_Tari_1616 Write 16 6 REG_Tari_1584 Write 16 7 REG_Pw Write 16 8 REG_Delimiter Write 16 9 REG_RTcal Write 16 10 REG_TRcal Write 16 3 REG_Status Read 32 4 REG_Receiver_data_out Read 32 5 REG_Sender_usedw Read 8 6 REG_Receiver_usedw Read 8 7 REG_IP-ID Read 32 While some registers indicate a single variable, such as those that indicate Tari values, others carry multiple peripheral control variables with them, those being REG_SETTINGS and REG_STATUS . 0 - REG_Settings (R/W) \u00b6 The Register Settings is responsible for the control of the IP_RFID, as a Read and Write register it is capable of setting flags, making pulses in specific bits and also activating components of the IP_RFID 31 30 29 28 27 26 25 24 x x x x x x x x 23 22 21 20 19 18 17 16 x x x x x x x x 15 14 13 12 11 10 9 8 x x x Receiver read request Receiver reset Sender clr finished send x Loopback 7 6 5 4 3 2 1 0 Sender is preamble Sender start controller Sender has_gen Receiver enable x Sender clear FIFO Sender enable Sender reset Bits 31 through 13 are not in use, instead being reserved for future implementations. Bit 12 - Receiver read request stores the read request flag for the Receiver FIFO; Bit 11 - Receiver reset stores the reset flag for the Receiver; Bit 10 - Sender clr finished send stores the Sender clear finished send flag; Bit 8 - Loopback stores the loopback flag used in testing the READER; Bit 7 - Sender is preamble stores the preamble flag for the Sender generator; Bit 6 - Sender start controller stores the start controller flag for the Sender; Bit 5 - Sender has_gen stores the generator flag for the Sender; Bit 4 - Receiver enable stores the enable flag for the Receiver; Bit 2 - Sender clear FIFO stores the clear FIFO flag for the Sender FIFO; Bit 1 - Sender enable stores the enable flag for the Sender; Bit 0 - Sender reset stores the reset flag for the Sender; 1 - REG_Tari (R/W) \u00b6 The Register Tari carries the time parameter to the IP Core, in the software it is declared as an int and can vary between 313 to 1250 values. These range is calculated by multiplying frequency of the \u00b5Processor times the tari range. The tari range is 6.25\u00b5s to 25\u00b5s, which is also stablished in EPC-GEN2 Documentation. The tari is written in the Register Tari from least significant (0) to most significant bit (15) of the register. Depending only on the binary value for the Integer mentioned previously 15 14 ... 2 1 0 x x ... x x x 2 - REG_FIFO (W) \u00b6 The register FIFO carries the package, from the C Software to the IP Rfid through Avalon bus. The FIFO register is also written from least significant (0) to most significant bit (31) of the register. In which the six least significant bits are the mask which carries the size of the data and the remaining 26 are reserved for data itself. 31 30 ... 2 1 0 x x ... x x x TARI limit Registers \u00b6 The Registers 3 to 6 are called Registers Tari Boundaries, they stablish the 1%-time variation in which the READER can communicate with the TAG. If the TAG does not reply in time or if the Sender or Receiver peripherals delay, an error flag will be raised as if the communication had ended. Each Tari Boundary is written its respective Register from least significant (0) to most significant bit (15) of the register. Depending only on the binary value for the Integer that it represents. 3 - REG_Tari_101 (W) 15 14 ... 2 1 0 x x ... x x x 4 - REG_Tari_099 (W) 15 14 ... 2 1 0 x x ... x x x 5 - REG_Tari_1616 (W) 15 14 ... 2 1 0 x x ... x x x 6 - REG_Tari_1584 (W) 15 14 ... 2 1 0 x x ... x x x Preamble and Framesync time parameter registers \u00b6 The following registers are also time parameters which can be seen in the Preamble and Frame-sync images, they are part of the RFID modulation and a future implementation of Radio frequency depends on these values to be set. Each value written its respective Register from least significant (0) to most significant bit (15) of the register. Depending only on the binary value for the Integer that it represents. 7 - REG_Pw (W) 15 14 ... 2 1 0 x x ... x x x 8 - REG_Delimiter (W) 15 14 ... 2 1 0 x x ... x x x 9 - REG_RTcal (W) 15 14 ... 2 1 0 x x ... x x x 10 - REG_TRcal (W) 15 14 ... 2 1 0 x x ... x x x 3 - REG_Status (R) \u00b6 In contrast to the REG_Settings , the REG_Status is a read only register from the processor. It carries errors and others status flags explained bellow. 31 30 29 28 27 26 25 24 x x x x x x x x 23 22 21 20 19 18 17 16 x x x x x x x x 15 14 13 12 11 10 9 8 x Receiver full Receiver empty Receiver sclear x Receiver clear error decoder Receiver error decoder x 7 6 5 4 3 2 1 0 x x x x Sender finished sending x x Sender is fifo full Bits 31 through 15 are not in use, instead being reserved for future implementations. Bit 14 - Receiver full stores the full flag for the Receiver FIFO; Bit 13 - Receiver empty stores the empty flag for the Recevier FIFO; Bit 12 - Receiver sclear stores the clear flag for the Receiver FIFO; Bit 10 - Receiver clear error decoder stores the clear error flag for the Receiver decoder; Bit 9 - Receiver error decoder stores the error flag for the Receiver decoder; Bit 3 - Sender finished sending stores the finished sending flag for the Sender FIFO; Bit 0 - Sender is fifo full stores the full flag for the Sender FIFO; 4 - REG_Receiver_data_out (R) \u00b6 The Register Receiver data out is the output of the Receiver peripheral from the IP Rfid. This Register carries a package built from the signal received, this package comes from the FIFO in which it was stored. A combination of one or more packages read from this register makes a command. This register is written from least significant (0) to most significant bit(31) of the register. In which the least six significant bits are the mask that carries the size of the data and the remaining 26 are reserved for data itself. 31 30 ... 2 1 0 x x ... x x x FIFO Package count Registers \u00b6 The next two registers store the number of packages in their respective FIFOs. The former being the Sender FIFO and the latter being the Receiver FIFO. Both registers are automatically filled by the Intel FIFO and are just read by the C software through the Avalon bus. 5 - REG_Sender_usedw (R) 7 6 ... 2 1 0 x x ... x x x 6 - REG_Receiver_usedw (R) 7 6 ... 2 1 0 x x ... x x x 7 - REG_IP-ID (R) \u00b6 This register stores the ID of the IP-Rfid so that is possible to verify if the software is communicating properly with the IP-Rfid and if it is correctly addressing the Avalon bus. The binary value above can be read in Hex as 0XFF0055FF , and it is written to the Register IP-ID from least significant (0) to most significant bit (31). 31 30 29 28 27 26 25 24 1 1 1 1 1 1 1 1 23 22 21 20 19 18 17 16 0 0 0 0 0 0 0 0 15 14 13 12 11 10 9 8 0 1 0 1 0 1 0 1 7 6 5 4 3 2 1 0 1 1 1 1 1 1 1 1","title":"Firmware"},{"location":"firmware/#firmware","text":"Below is an in depth explanation of the mechanism responsible for the communication between the NIOS II processor and the IP Core, which is composed by the Avalon Interface and a register bank that connect the other components.","title":"Firmware"},{"location":"firmware/#avalon-interface","text":"The Avalon Interface, according to its developer Intel (in \u201cAvalon\u00ae Interface Specifications\u201d, 2021, p.4): \"Avalon\u00ae interfaces simplify system design by allowing you to easily connect components in Intel\u00ae FPGA. The Avalon interface family defines interfaces appropriate for streaming high-speed data, reading, and writing registers and memory, and controlling off-chip devices. Components available in Platform Designer incorporate these standard interfaces. Additionally, you can incorporate Avalon interfaces in custom components, enhancing the interoperability of designs.\". In other words, it is possible to conclude from this excerpt that, in addition to enabling the connection between Intel\u00ae FPGA components, that once the interfaces are added to Platform Designer, they can connect custom components, which we use for the IP-Rfid in our product. All documentation for other possible interfaces and connection is present in the document \u201cAvalon\u00ae Interface Specifications\u201d. The Avalon Bus can be implemented with multiple features and modules. In this project, Avalon Memory-Mapped will be used, but other alternatives were considered, such as Avalon Interrupt Interfaces and Avalon Streaming Interfaces. The Avalon Memory-Mapped (Avalon-MM) interface implements the writing and reading of interfaces for the other components used, including Memory, UART Chip and the NIOS II. The interface uses a Host and Agent system in which the Host is the provider of data and commands to the Agent, while the Agent responds to the Host. These relations can be viewed in the images below, which represent an example of Host and Agent communication in the first image, and an example of writing to an address in the second one.","title":"Avalon Interface"},{"location":"firmware/#register-bank","text":"The register bank intermediates the communication between the NIOS II processor and the IP Core. Each access to the bus is done through a read or write command in which they carry data up to 32 bits, a value that represents the size of an integer in the programming language C, as it is the one implemented in the processor. As seen in the table, this communication path is responsible for the IP peripheral settings, informing essential values for communication such as Tari , Delimiter and Status , as well as others shown below. offset Name Access Size (bits) 0 REG_Settings Read/Write 32 1 REG_Tari Read/Write 16 2 REG_FIFO Write 32 3 REG_Tari_101 Write 16 4 REG_Tari_099 Write 16 5 REG_Tari_1616 Write 16 6 REG_Tari_1584 Write 16 7 REG_Pw Write 16 8 REG_Delimiter Write 16 9 REG_RTcal Write 16 10 REG_TRcal Write 16 3 REG_Status Read 32 4 REG_Receiver_data_out Read 32 5 REG_Sender_usedw Read 8 6 REG_Receiver_usedw Read 8 7 REG_IP-ID Read 32 While some registers indicate a single variable, such as those that indicate Tari values, others carry multiple peripheral control variables with them, those being REG_SETTINGS and REG_STATUS .","title":"Register Bank"},{"location":"firmware/#0-reg_settings-rw","text":"The Register Settings is responsible for the control of the IP_RFID, as a Read and Write register it is capable of setting flags, making pulses in specific bits and also activating components of the IP_RFID 31 30 29 28 27 26 25 24 x x x x x x x x 23 22 21 20 19 18 17 16 x x x x x x x x 15 14 13 12 11 10 9 8 x x x Receiver read request Receiver reset Sender clr finished send x Loopback 7 6 5 4 3 2 1 0 Sender is preamble Sender start controller Sender has_gen Receiver enable x Sender clear FIFO Sender enable Sender reset Bits 31 through 13 are not in use, instead being reserved for future implementations. Bit 12 - Receiver read request stores the read request flag for the Receiver FIFO; Bit 11 - Receiver reset stores the reset flag for the Receiver; Bit 10 - Sender clr finished send stores the Sender clear finished send flag; Bit 8 - Loopback stores the loopback flag used in testing the READER; Bit 7 - Sender is preamble stores the preamble flag for the Sender generator; Bit 6 - Sender start controller stores the start controller flag for the Sender; Bit 5 - Sender has_gen stores the generator flag for the Sender; Bit 4 - Receiver enable stores the enable flag for the Receiver; Bit 2 - Sender clear FIFO stores the clear FIFO flag for the Sender FIFO; Bit 1 - Sender enable stores the enable flag for the Sender; Bit 0 - Sender reset stores the reset flag for the Sender;","title":"0 - REG_Settings (R/W)"},{"location":"firmware/#1-reg_tari-rw","text":"The Register Tari carries the time parameter to the IP Core, in the software it is declared as an int and can vary between 313 to 1250 values. These range is calculated by multiplying frequency of the \u00b5Processor times the tari range. The tari range is 6.25\u00b5s to 25\u00b5s, which is also stablished in EPC-GEN2 Documentation. The tari is written in the Register Tari from least significant (0) to most significant bit (15) of the register. Depending only on the binary value for the Integer mentioned previously 15 14 ... 2 1 0 x x ... x x x","title":"1 - REG_Tari (R/W)"},{"location":"firmware/#2-reg_fifo-w","text":"The register FIFO carries the package, from the C Software to the IP Rfid through Avalon bus. The FIFO register is also written from least significant (0) to most significant bit (31) of the register. In which the six least significant bits are the mask which carries the size of the data and the remaining 26 are reserved for data itself. 31 30 ... 2 1 0 x x ... x x x","title":"2 - REG_FIFO (W)"},{"location":"firmware/#tari-limit-registers","text":"The Registers 3 to 6 are called Registers Tari Boundaries, they stablish the 1%-time variation in which the READER can communicate with the TAG. If the TAG does not reply in time or if the Sender or Receiver peripherals delay, an error flag will be raised as if the communication had ended. Each Tari Boundary is written its respective Register from least significant (0) to most significant bit (15) of the register. Depending only on the binary value for the Integer that it represents. 3 - REG_Tari_101 (W) 15 14 ... 2 1 0 x x ... x x x 4 - REG_Tari_099 (W) 15 14 ... 2 1 0 x x ... x x x 5 - REG_Tari_1616 (W) 15 14 ... 2 1 0 x x ... x x x 6 - REG_Tari_1584 (W) 15 14 ... 2 1 0 x x ... x x x","title":"TARI limit Registers"},{"location":"firmware/#preamble-and-framesync-time-parameter-registers","text":"The following registers are also time parameters which can be seen in the Preamble and Frame-sync images, they are part of the RFID modulation and a future implementation of Radio frequency depends on these values to be set. Each value written its respective Register from least significant (0) to most significant bit (15) of the register. Depending only on the binary value for the Integer that it represents. 7 - REG_Pw (W) 15 14 ... 2 1 0 x x ... x x x 8 - REG_Delimiter (W) 15 14 ... 2 1 0 x x ... x x x 9 - REG_RTcal (W) 15 14 ... 2 1 0 x x ... x x x 10 - REG_TRcal (W) 15 14 ... 2 1 0 x x ... x x x","title":"Preamble and Framesync time parameter registers"},{"location":"firmware/#3-reg_status-r","text":"In contrast to the REG_Settings , the REG_Status is a read only register from the processor. It carries errors and others status flags explained bellow. 31 30 29 28 27 26 25 24 x x x x x x x x 23 22 21 20 19 18 17 16 x x x x x x x x 15 14 13 12 11 10 9 8 x Receiver full Receiver empty Receiver sclear x Receiver clear error decoder Receiver error decoder x 7 6 5 4 3 2 1 0 x x x x Sender finished sending x x Sender is fifo full Bits 31 through 15 are not in use, instead being reserved for future implementations. Bit 14 - Receiver full stores the full flag for the Receiver FIFO; Bit 13 - Receiver empty stores the empty flag for the Recevier FIFO; Bit 12 - Receiver sclear stores the clear flag for the Receiver FIFO; Bit 10 - Receiver clear error decoder stores the clear error flag for the Receiver decoder; Bit 9 - Receiver error decoder stores the error flag for the Receiver decoder; Bit 3 - Sender finished sending stores the finished sending flag for the Sender FIFO; Bit 0 - Sender is fifo full stores the full flag for the Sender FIFO;","title":"3 - REG_Status (R)"},{"location":"firmware/#4-reg_receiver_data_out-r","text":"The Register Receiver data out is the output of the Receiver peripheral from the IP Rfid. This Register carries a package built from the signal received, this package comes from the FIFO in which it was stored. A combination of one or more packages read from this register makes a command. This register is written from least significant (0) to most significant bit(31) of the register. In which the least six significant bits are the mask that carries the size of the data and the remaining 26 are reserved for data itself. 31 30 ... 2 1 0 x x ... x x x","title":"4 - REG_Receiver_data_out (R)"},{"location":"firmware/#fifo-package-count-registers","text":"The next two registers store the number of packages in their respective FIFOs. The former being the Sender FIFO and the latter being the Receiver FIFO. Both registers are automatically filled by the Intel FIFO and are just read by the C software through the Avalon bus. 5 - REG_Sender_usedw (R) 7 6 ... 2 1 0 x x ... x x x 6 - REG_Receiver_usedw (R) 7 6 ... 2 1 0 x x ... x x x","title":"FIFO Package count Registers"},{"location":"firmware/#7-reg_ip-id-r","text":"This register stores the ID of the IP-Rfid so that is possible to verify if the software is communicating properly with the IP-Rfid and if it is correctly addressing the Avalon bus. The binary value above can be read in Hex as 0XFF0055FF , and it is written to the Register IP-ID from least significant (0) to most significant bit (31). 31 30 29 28 27 26 25 24 1 1 1 1 1 1 1 1 23 22 21 20 19 18 17 16 0 0 0 0 0 0 0 0 15 14 13 12 11 10 9 8 0 1 0 1 0 1 0 1 7 6 5 4 3 2 1 0 1 1 1 1 1 1 1 1","title":"7 - REG_IP-ID (R)"},{"location":"getting_started/","text":"Getting Started \u00b6 Tools \u00b6 To be able to use the Conformance Tester for TAGs EPC-GEN2 UHF RFID, you'll need the following tools: Hardware: DE10-Standard + accessories jumpers Software: Quartus Prime Lite Edition 18.1 Cyclone V device support ModelSim-Intel FPGA Edition git You can find the software downloads here . The user manual for the DE-10 Standard board can be found here . Cloning \u00b6 To clone the project, run the following command on your preferred terminal. git clone https://github.com/pfeinsper/21b-indago-rfid-conformance-tester.git The repository is now cloned, and you can start testing/running the project. Testing / Running \u00b6 First, launch Quartus Prime. After launching, click on File \u27a1\ufe0f Open Project . A window will pop up, and you need to choose the rfid-conformance-tester.qpf file, located in the fpga folder of the repository. The video below shows how to do so. Once the project has been opened, you can work on it; however, the steps to run the project depend on whether you want to simulate using ModelSim or whether you want to launch on the DE-10 Standard board. ModelSim guide \u00b6 To test and simulate the project on ModelSim, the first step is to check the files present in the project. Click on Project \u27a1\ufe0f Add/Remove Files in Project . It should look like the picture below. After checking the files, go to Project Navigator on the left panel, click on the dropdown menu that says Hierarchy , then click on Files . After that, right-click on the RTL/rfid.vhd file, and click on the option that says Set as Top-Level Entity . Now you can click on the blue play button next to the stop button to start the compilation. Once the project is compiled, click on Tools \u27a1\ufe0f Platform Designer . A new window should open. Find the RFID_NIOS.qsys file, and open it. Once you've opened the file, it should show the project's design. On this window, click on Generate \u27a1\ufe0f Generate Testbench System... . Make sure the settings are as follows, and click on Generate on the bottom. Next, you wanna open up the Nios II Software Build Tools for Eclipse . If it's your first time opening this tool, the Eclipse window will ask you to choose a workspace. Now the Eclipse window should be open with a blank workspace like the one below. Now we need to import our projects into Eclipse. Go to File \u27a1\ufe0f Import , and it should show a window like the one below. Click on Nios II Software Build Tools Project \u27a1\ufe0f Import Nios II Software Build Tools Project , then click Next . Now you need to click on the Browse button and look for the project. The projects are located at 21b-indago-rfid-conformance-tester/fpga/software . First, import the rfid_test project, then click Finish , and make sure that the Clean project when importing box is checked. Do the same steps for the rfid_test_bsp project. After both projects have been imported, right-click on rfid_test_bsp \u27a1\ufe0f BSP Editor . It will open a window like the one below. Make sure that the options are all the same. You also need to check the enable_small_driver box on the Drivers tab. After checking the settings, click on the Generate button. Once you generated the BSP, right-click the rfid_test \u27a1\ufe0f Build Project . If you had any errors, try cleaning both projects, generating the BSP and rebuilding the project. Once the build is complete, go to Run \u27a1\ufe0f Run configurations . It should open up a new window. Right click on Nios II Modelsim , and click on New . A new ModelSim run configuration has been created, and you can click on Run to simulate. The image below shows the configuration settings. You can also watch the video below, which shows the step-by-step process. Hardware guide \u00b6 Important: If you want to launch the project on the DE-10 Standard board, a Quartus License is required. To launch the project on the DE-10 Standard board, the first step is to check the files present in the project. Click on Project \u27a1\ufe0f Add/Remove Files in Project . It should look like the picture below. If you are missing the RFID_NIOS.qip file, you can generate it using the Platform Designer . You can follow the same instructions used on the ModelSim guide to open the Platform Designer and open the project's design. Once the design is open, click on Generate \u27a1\ufe0f Generate HDL... . The settings should match the ones present in the image below. After that, just click on the Generate button, and it should generate the IP variation file. After checking the files, go to Project Navigator on the left panel, click on the dropdown menu that says Hierarchy , then click on Files . After that, right-click on the RTL/rfid_nios_HW.vhd file, and click on the option that says Set as Top-Level Entity . Now you can click on the blue play button next to the stop button to start the compilation. After compiling, go to Tools \u27a1\ufe0f Programmmer to program the board. Be sure that the board is plugged in before opening. If your board is not showing up on the Hardware menu on top, click on Hardware Setup , then double click on your board in the menu. After selecting your board, close this window. Once your board is shown in the Hardware menu, click on the Auto Detect button on the left menu, and select the corresponding device name for your board (it is engraved on the chip, shown in the image below). After selecting the corresponding device name, the program may show two chips: one named SOCVHPS and the other with your device. Double-click on the File tab next to the name of your device, and look for the rfid-conformance-tester.sof file for the compiled project, located on the 21b-indago-rfid-conformance-tester/fpga/output_files folder. Once you selected the file, check the Program/Configure box next to your device as is shown in the image below, then click on Start to program the board. Once it's finished, you can close the Programmer window. After programming the board, get a female/female jumper, plug one end on pin 6 of the GPIO header and the other end on pin 7 of the GPIO header, as shown in the images below. Once the jumpers are connected, open up the Nios II Software Build Tools for Eclipse . You can follow the same steps shown in the ModelSim guide on how to do so. After both projects have been imported, right-click on rfid_test_bsp \u27a1\ufe0f BSP Editor .Make sure that the options are the same as the ones present in the image below (they are not the same settings from the ModelSim guide). The enable_small_driver box on the Drivers tab needs to be kept checked. After checking the settings, click on the Generate button on the editor. Once you generated the BSP, right-click the rfid_test \u27a1\ufe0f Build Project . If you had any errors, try cleaning both projects, generating the BSP and rebuilding the project. Once the build is complete, go to Run \u27a1\ufe0f Run configurations . It should open up a new window. Right click on Nios II Hardware , and click on New . Once the configuration has been created, go to the Target Connection tab, and check if the settings are the same as the one shown in the image below. Once you checked the settings, you can click on Run to launch. You can also watch the video below, which shows the step-by-step process. Hardware guide - part 2 \u00b6 You can also run a handshake version of the project using two DE-10 Standard boards. To do so, follow the same steps shown on the hardware guide until you reach the rfid_test project build. Before building the project, you need to find the tag.c and reader.c files, located in the fpga folder. Choose one board to act as the tag, and one board to act as the reader; after that, replace the code present in the hello_world.c with the corresponding code (one board will have the tag.c code and the other will have the reader.c code). After overwriting the code, build the project on each Nios environment. Once the projects are built, make sure that the boards are plugged as shown in the image below. Once the pins are properly plugged, you can use the same run configurations created on the hardware guide to run the project. Important: First, launch the tag configuration, and wait for the Nios II Console to print waiting for query . After that, you can launch the reader configuration. You can also watch the video below, which shows the step-by-step process. How to collaborate \u00b6 Firstly, you should create a fork of the original repository to work on. You can learn how to do so here . After creating your own fork, you can open a pull request to this repository. The instructions on how to do it can be found here . After making your pull request, it will be reviewed by one of the team members, and if everything's ok, they will approve it. If there are problems with your pull request, the reviewer will inform you of them, and you can make the adjustments necessary.","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#tools","text":"To be able to use the Conformance Tester for TAGs EPC-GEN2 UHF RFID, you'll need the following tools: Hardware: DE10-Standard + accessories jumpers Software: Quartus Prime Lite Edition 18.1 Cyclone V device support ModelSim-Intel FPGA Edition git You can find the software downloads here . The user manual for the DE-10 Standard board can be found here .","title":"Tools"},{"location":"getting_started/#cloning","text":"To clone the project, run the following command on your preferred terminal. git clone https://github.com/pfeinsper/21b-indago-rfid-conformance-tester.git The repository is now cloned, and you can start testing/running the project.","title":"Cloning"},{"location":"getting_started/#testing-running","text":"First, launch Quartus Prime. After launching, click on File \u27a1\ufe0f Open Project . A window will pop up, and you need to choose the rfid-conformance-tester.qpf file, located in the fpga folder of the repository. The video below shows how to do so. Once the project has been opened, you can work on it; however, the steps to run the project depend on whether you want to simulate using ModelSim or whether you want to launch on the DE-10 Standard board.","title":"Testing / Running"},{"location":"getting_started/#modelsim-guide","text":"To test and simulate the project on ModelSim, the first step is to check the files present in the project. Click on Project \u27a1\ufe0f Add/Remove Files in Project . It should look like the picture below. After checking the files, go to Project Navigator on the left panel, click on the dropdown menu that says Hierarchy , then click on Files . After that, right-click on the RTL/rfid.vhd file, and click on the option that says Set as Top-Level Entity . Now you can click on the blue play button next to the stop button to start the compilation. Once the project is compiled, click on Tools \u27a1\ufe0f Platform Designer . A new window should open. Find the RFID_NIOS.qsys file, and open it. Once you've opened the file, it should show the project's design. On this window, click on Generate \u27a1\ufe0f Generate Testbench System... . Make sure the settings are as follows, and click on Generate on the bottom. Next, you wanna open up the Nios II Software Build Tools for Eclipse . If it's your first time opening this tool, the Eclipse window will ask you to choose a workspace. Now the Eclipse window should be open with a blank workspace like the one below. Now we need to import our projects into Eclipse. Go to File \u27a1\ufe0f Import , and it should show a window like the one below. Click on Nios II Software Build Tools Project \u27a1\ufe0f Import Nios II Software Build Tools Project , then click Next . Now you need to click on the Browse button and look for the project. The projects are located at 21b-indago-rfid-conformance-tester/fpga/software . First, import the rfid_test project, then click Finish , and make sure that the Clean project when importing box is checked. Do the same steps for the rfid_test_bsp project. After both projects have been imported, right-click on rfid_test_bsp \u27a1\ufe0f BSP Editor . It will open a window like the one below. Make sure that the options are all the same. You also need to check the enable_small_driver box on the Drivers tab. After checking the settings, click on the Generate button. Once you generated the BSP, right-click the rfid_test \u27a1\ufe0f Build Project . If you had any errors, try cleaning both projects, generating the BSP and rebuilding the project. Once the build is complete, go to Run \u27a1\ufe0f Run configurations . It should open up a new window. Right click on Nios II Modelsim , and click on New . A new ModelSim run configuration has been created, and you can click on Run to simulate. The image below shows the configuration settings. You can also watch the video below, which shows the step-by-step process.","title":"ModelSim guide"},{"location":"getting_started/#hardware-guide","text":"Important: If you want to launch the project on the DE-10 Standard board, a Quartus License is required. To launch the project on the DE-10 Standard board, the first step is to check the files present in the project. Click on Project \u27a1\ufe0f Add/Remove Files in Project . It should look like the picture below. If you are missing the RFID_NIOS.qip file, you can generate it using the Platform Designer . You can follow the same instructions used on the ModelSim guide to open the Platform Designer and open the project's design. Once the design is open, click on Generate \u27a1\ufe0f Generate HDL... . The settings should match the ones present in the image below. After that, just click on the Generate button, and it should generate the IP variation file. After checking the files, go to Project Navigator on the left panel, click on the dropdown menu that says Hierarchy , then click on Files . After that, right-click on the RTL/rfid_nios_HW.vhd file, and click on the option that says Set as Top-Level Entity . Now you can click on the blue play button next to the stop button to start the compilation. After compiling, go to Tools \u27a1\ufe0f Programmmer to program the board. Be sure that the board is plugged in before opening. If your board is not showing up on the Hardware menu on top, click on Hardware Setup , then double click on your board in the menu. After selecting your board, close this window. Once your board is shown in the Hardware menu, click on the Auto Detect button on the left menu, and select the corresponding device name for your board (it is engraved on the chip, shown in the image below). After selecting the corresponding device name, the program may show two chips: one named SOCVHPS and the other with your device. Double-click on the File tab next to the name of your device, and look for the rfid-conformance-tester.sof file for the compiled project, located on the 21b-indago-rfid-conformance-tester/fpga/output_files folder. Once you selected the file, check the Program/Configure box next to your device as is shown in the image below, then click on Start to program the board. Once it's finished, you can close the Programmer window. After programming the board, get a female/female jumper, plug one end on pin 6 of the GPIO header and the other end on pin 7 of the GPIO header, as shown in the images below. Once the jumpers are connected, open up the Nios II Software Build Tools for Eclipse . You can follow the same steps shown in the ModelSim guide on how to do so. After both projects have been imported, right-click on rfid_test_bsp \u27a1\ufe0f BSP Editor .Make sure that the options are the same as the ones present in the image below (they are not the same settings from the ModelSim guide). The enable_small_driver box on the Drivers tab needs to be kept checked. After checking the settings, click on the Generate button on the editor. Once you generated the BSP, right-click the rfid_test \u27a1\ufe0f Build Project . If you had any errors, try cleaning both projects, generating the BSP and rebuilding the project. Once the build is complete, go to Run \u27a1\ufe0f Run configurations . It should open up a new window. Right click on Nios II Hardware , and click on New . Once the configuration has been created, go to the Target Connection tab, and check if the settings are the same as the one shown in the image below. Once you checked the settings, you can click on Run to launch. You can also watch the video below, which shows the step-by-step process.","title":"Hardware guide"},{"location":"getting_started/#hardware-guide-part-2","text":"You can also run a handshake version of the project using two DE-10 Standard boards. To do so, follow the same steps shown on the hardware guide until you reach the rfid_test project build. Before building the project, you need to find the tag.c and reader.c files, located in the fpga folder. Choose one board to act as the tag, and one board to act as the reader; after that, replace the code present in the hello_world.c with the corresponding code (one board will have the tag.c code and the other will have the reader.c code). After overwriting the code, build the project on each Nios environment. Once the projects are built, make sure that the boards are plugged as shown in the image below. Once the pins are properly plugged, you can use the same run configurations created on the hardware guide to run the project. Important: First, launch the tag configuration, and wait for the Nios II Console to print waiting for query . After that, you can launch the reader configuration. You can also watch the video below, which shows the step-by-step process.","title":"Hardware guide - part 2"},{"location":"getting_started/#how-to-collaborate","text":"Firstly, you should create a fork of the original repository to work on. You can learn how to do so here . After creating your own fork, you can open a pull request to this repository. The instructions on how to do it can be found here . After making your pull request, it will be reviewed by one of the team members, and if everything's ok, they will approve it. If there are problems with your pull request, the reviewer will inform you of them, and you can make the adjustments necessary.","title":"How to collaborate"},{"location":"hardware/","text":"Hardware \u00b6 For this project, the chosen solution for implementing the conformance tester was to develop a dedicated hardware in FPGA 1 . The chosen product was the DE10-Standard produced by Terasic as well as a PFGA Cyclone V from Intel. Our teacher had ample experience working with this specific model, and it also perfectly fits the requirements need to implement the chosen solution. This is because, through a tool called \"platform designer\", it can edit its configuration on demand, allowing great flexibility when needed. The proposed solution makes use of Intel's solution development ecosystem, providing flexibility in the use of a soft processor, enabling the integration of peripherals called IP-Rfid to its architecture, as well as allowing the creation of new instructions implemented in the hardware. For more information on these modifications, see the document \"NIOS II Custom Instruction User Guide\" 2 . File Hierarchy \u00b6 All necessary VHDL hardware description files are located in the project\u2019s fpga/rtl/ folder. The top entity of the entire processor including all the required configuration generics is rfid.vhd. rfid.vhd - Conformance tester top entity \u2502 \u251csender.vhd - Sender component top entity \u2502\u251cFIFO_fm0.vhd - Encoder-specific FIFO \u2502\u2502\u251cFM0_encoder.vhd - Encoder-FM0-specific FIFO \u2502\u2502\u2514fifo_32_32.vhd - General use FIFO \u2502\u251csender_controller.vhd - Controls the flow of packages to the TAG \u2502\u2514signal_generator.vhd - Generates preamble or frame-sync signal \u2502 \u2514receiver.vhd - Receiver component top entity \u251cFM0_decoder.vhd - Decoder-FM0-specific FIFO \u251cfifo_32_32.vhd - General use FIFO \u2514package_constructor.vhd - Stores bits into packages before storing in the FIFO Packages and commands \u00b6 Our project uses the mandatory commands specified in the EPC-GEN2 documentation. However, those commands have varying sizes and even the same command could vary its size based on the data it sends. To work with this fluctuating command bit size, the group decided to break commands into 32-bit packages, where the 26 more significant bits are the actual data of the packet, and the 6 less significant are the mask, indicating how many of the 26 are in use. This way, we have three possible situations given the command sizes: The command is larger than one package: if the command has more than 26 bits, we are able to break it into multiple packages, communicated in order through our components (more significant -> less significant); The command is the same size as the package: the easiest case, where we just treat the package as the full command; The command is shorter than one package: in this case we just fill the package up to the number of bits the command has, and then use the mask to communicate how many of the data bits in the package are useful, ignoring the ones not needed to the command; For example, if a command has 40 bits, we will break it into two packets. The first one uses the 26 data bits, and the mask 011010 (26) to indicate all the data bits are in use. Then, the second package would only use 14 of the 26 data bits available to reach the 40 bits the command has, and so the mask would be 001110 (14) to indicate that only 14 bits should be analyzed. To communicate between the components that the command is over, we send a void package 0b00000000000000000000000000000000 after the last package of the command. This occurs in two times in out product: first, when sending the command to the TAG, the NIOS II sends a void package to the Sender to indicate the command is over. Second, when receiving the response from the TAG, the Recevier sends a void package to the NIOS II to indicate that the command received is over. READER \u00b6 The READER, as shown in the diagram below, is the toplevel of our project, which contains the three main components. Here we will give an overview of each component, and a in depth analysis is present in the sections below. The first one is the NIOS II soft processor, where we programmed the tests that will be run on the TAG. Therefore, its responsible for generating the commands for communicating with the TAG, as well as interpreting the responses it receives, to assert whether the TAG passes or fails each test. The second component is the IP-Rfid, developed in VHDL, and is responsible for encoding and sending messages to the TAG, as well as decoding any responses and passing the through to the processor. Those two tasks have been separated into the sender and the receiver respectively. The last one is the Avalon Interface, is the connection between the NIOS II and the IP-Rfid, where the commands, generated in the programming language C, will be passed on to the VHDL sender, and responses will take the opposite path, going from the receiver to the processor. IP-Rfid \u00b6 /main/fpga/RTL/rfid.vhd The developed peripheral can be split into two components, visualized in the diagram below. Those are the SENDER, in red, responsible for receiving the data from the NIOS II, encoding and forwarding them to the TAG; and the RECEIVER, in blue, responsible for receiving the data from the TAG, decoding and forwarding them to the NIOS II. SENDER \u00b6 This component is responsible for encoding the commands generated by the processor, and send them to the TAG, respecting the rules of the EPC-GEN2 protocol, including the TARI, preamble and EOP. Its components are detailed below: FIFO The first component of the SENDER is the FIFO, a storage system that receives the assembled commands from the NIOS II and waits for the encoder to send the read request flag, signaling for the FIFO to send the oldest package. It is possible that the command to be sent to the TAG is composed of more than one package, so the FIFO serves as a storage system for packages already received from the processor until it signals that the entire command is ready for encoding. For this project, we opted to use the FIFO produced by Intel, which was obtained through the Quartus automatic generator, the main software used by the group for programming in VHDL language. It is possible to include several customizations before generating the code, and thus, the group defined that the FIFO would have, reset , write request , read request , FIFO full and FIFO empty flags to facilitate communication with other components of the project. Furthermore, it has a 32-bit word and a depth of 248 words. FIFO_FM0 FIFO-FM0 is a component created to separate the data encoding component from the signal-generator and the sender-controller, mapping the inputs: data to be encoded, write request for the FIFO, enable and tari to the other components, allowing for individual control of each component. Since the encoder does not need to obey the tari, it can operate independently, and much faster than the sender, since each bit can only be sent after the tari interval. Encoder The encoder is the main component of the sender, being responsible for encoding the packages received from the FIFO with FM0 band, as specified in the EPC-GEN2, as well as sending the encoded data to the TAG. for this purpose, a refined control of the time intervals is necessary to obey the TARI, also defined in the protocol as being between 6.25\u03bcs and 25\u03bcs. This component has two state machines that work simultaneously, one responsible for communicating with the FIFO and sending it to the TAG, while the other encodes the received data. The diagram below demonstrates the first state machine: Wait is the encoder's default, the state it remains in while it doesn't receive any new packages to encode; Start Send is the most complex state, where another state machine is present inside it, which is responsible for encoding the packages. Furthermore, it also expects to receive the correct TARI to send data to the TAG; Wait Send is a temporary state for when the data has been fully encoded, but due to the TARI limitations, has not been fully sent to the TAG yet. Once it finishes sending the data, it goes to the next state, Request Data ; Request Data happens after the data has been sent, and signals the FIFO to send more data. This state is very short, as its only duty is to send a flag to the FIFO, and immediately change to the Wait Request state; Wait Request can happen in two situations. First, if the Encoder is waiting for the next package from the FIFO, going back to the Start Send state once it is received. Second, it can happen once the FIFO sends the FIFO_empty signal to the Encoder. In this case, it will proceed to the Wait 1.6 TARI state; Wait 1.6 TARI is the formal completion of the command sent to the TAG, where a dummy 1 bit is sent, which will remain active for 1.6 TARI and then stop the communication; The next image demonstrates the other state machine present in the component, responsible for the encoding of the data. It was defined that it would always start in state S3 . FM0 encoding transforms each bit of information into two bits, in such a way so that a 1 becomes two bits of the same value (either 1 1 or 0 0 ), and a 0 becomes two bits of different values (either 1 0 or 0 1 ), where the signal always alternates when encoding a new bit. The change of state occurs after each bit has been sent and is defined by the value of the next bit. S1 encodes 1 into 1 1 ; S2 encodes 0 into 1 0 ; S3 encodes 0 into 0 1 ; S4 encodes 1 into 0 0 ; The previously defined dummy 1 acts as the EOP of a command passed to the TAG, however it also needs to be encoded, and is always followed by a 0 bit. This is shown in the image below. Signal Generator This component encompasses both the Preamble and Frame-sync functions, and receives flags to determine which one, if any, will be activated. The Frame-sync is responsible for defining and regulating the interval at which information is sent to the TAG, and sharing this interval to all other SENDER components, so that they can communicate within the correct time intervals. This period, named TARI, must be within the range defined in the protocol, and have a variation of less than 1% between each pulse. The Preamble is responsible for the first wave of information sent to the TAG for each new command, and it defines which TARI will be used throughout the next command. This component needs to be activated for every command that is sent to the TAG, except when more than one command is sent in sequence, without a response in between. In this case, the preamble informed will be valid for all subsequent commands, until a response is requested. RECEIVER \u00b6 The RECEIVER is responsible for receiving the responses from the TAG, decode them, and notify the NIOS II processor that there was a response, as well as store each package of the response until the processor sends the read request flags to analyze them. In order for the received data to be interpreted, it is necessary that the information is decoded and grouped into packages, because it is possible the response is too large for the processor to receive all at once. The group decided to split the RECEIVER into three smaller components, shown and described below: Decoder Since the TAG also communicates back to the READER using FM0 encoding, a decoder component is needed to decode the received data, allowing it to be interpreted by the processor. This component was built in a similar way to the sender, though it is a simpler process, and only one state machine was needed. The diagram below demonstrates the state machine programmed for this purpose: Wait is the decoder's default, the state it remains in while it doesn't receive any new data to decode; Start Counter starts a time counter as soon as the decoder receives new data, in order to determine if the bit will change after 0.5 or 1.0 TARI, then passing to the next state. It is also possible for the bit to remain unchanged for more than 1.0 TARI, in which case it will go to the Pass 1.01 TARI state; Stop Counter sends 1 to the package constructor if the input signal has not changed, and 0 otherwise; Continue Counter is necessary because the stop counter always stop at 0.5 TARI, so it is activated if no bit change occurs; Pass 1.01 TARI is activated when the TAG sends the dummy 1 , which has a duration of 1.6 TARI, and checks if the times are in accordance with the protocol; Counter CS stops the counter and resets the decoder to its default state; ERROR is a state that can be activated by almost any other state, as they all check certain characteristics of that TAG that must comply with the protocol. If something is irregular, this status will be activated and will send an error message explaining what caused this to happen; Package Constructor This component is responsible for assembling the decoded bits into packages and storing them in the FIFO. It gathers the received bits until reaching the limit defined in the code, and then sending to the FIFO. If, however, the package constructor receives the EOP signal before completing the package, it will concatenate a mask with the current package to inform how many bits were filled. Furthermore, it will also extend the EOP flag to the FIFO and the processor, so that they know the RECEIVER has finished capturing and decoding the whole response command. Wait is the package constructor's default, the state it remains in while it doesn't receive any new data to store; New Bit happens when the decoder sends a decoded bit to the package constructor, which stores it in the current package being constructed; Inc Mask increases the package mask by 1 representing the new bit received; Max Mask checks whether the mask, and therefore the package, is full, preparing to send the package if it is; Send Package sends the current package to the FIFO, an intermediary step before going to the NIOS II processor; Check EOP checks if the EOP flag is high, and changes state based on the current packet. If it is empty, goes to the Send void state, if not goes to the Send Package ; Clear clears the current package before starting a new one; Send Void send to the FIFO an empty package - 0b00000000000000000000000000000000 FIFO The FIFO in the RECEIVER is the same as the one in the SENDER and serves similar purpose, however with inverted direction. This FIFO stores packages leaving the package constructor until it receives the EOP flag, which also signals the NIOS II that the command is ready to be requested. After this, the FIFO sends the packages to the processor one at a time, each time it receives a read request flag. FPGA Intel. https://www.intel.com.br/content/www/br/pt/products/programmable.html Accessed on: 23/08/2021 \u21a9 Nios II Custom Instruction User Guide. https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/ug/ug_nios2_custom_instruction.pdf Acessed on: 23/08/2021. \u21a9","title":"Hardware"},{"location":"hardware/#hardware","text":"For this project, the chosen solution for implementing the conformance tester was to develop a dedicated hardware in FPGA 1 . The chosen product was the DE10-Standard produced by Terasic as well as a PFGA Cyclone V from Intel. Our teacher had ample experience working with this specific model, and it also perfectly fits the requirements need to implement the chosen solution. This is because, through a tool called \"platform designer\", it can edit its configuration on demand, allowing great flexibility when needed. The proposed solution makes use of Intel's solution development ecosystem, providing flexibility in the use of a soft processor, enabling the integration of peripherals called IP-Rfid to its architecture, as well as allowing the creation of new instructions implemented in the hardware. For more information on these modifications, see the document \"NIOS II Custom Instruction User Guide\" 2 .","title":"Hardware"},{"location":"hardware/#file-hierarchy","text":"All necessary VHDL hardware description files are located in the project\u2019s fpga/rtl/ folder. The top entity of the entire processor including all the required configuration generics is rfid.vhd. rfid.vhd - Conformance tester top entity \u2502 \u251csender.vhd - Sender component top entity \u2502\u251cFIFO_fm0.vhd - Encoder-specific FIFO \u2502\u2502\u251cFM0_encoder.vhd - Encoder-FM0-specific FIFO \u2502\u2502\u2514fifo_32_32.vhd - General use FIFO \u2502\u251csender_controller.vhd - Controls the flow of packages to the TAG \u2502\u2514signal_generator.vhd - Generates preamble or frame-sync signal \u2502 \u2514receiver.vhd - Receiver component top entity \u251cFM0_decoder.vhd - Decoder-FM0-specific FIFO \u251cfifo_32_32.vhd - General use FIFO \u2514package_constructor.vhd - Stores bits into packages before storing in the FIFO","title":"File Hierarchy"},{"location":"hardware/#packages-and-commands","text":"Our project uses the mandatory commands specified in the EPC-GEN2 documentation. However, those commands have varying sizes and even the same command could vary its size based on the data it sends. To work with this fluctuating command bit size, the group decided to break commands into 32-bit packages, where the 26 more significant bits are the actual data of the packet, and the 6 less significant are the mask, indicating how many of the 26 are in use. This way, we have three possible situations given the command sizes: The command is larger than one package: if the command has more than 26 bits, we are able to break it into multiple packages, communicated in order through our components (more significant -> less significant); The command is the same size as the package: the easiest case, where we just treat the package as the full command; The command is shorter than one package: in this case we just fill the package up to the number of bits the command has, and then use the mask to communicate how many of the data bits in the package are useful, ignoring the ones not needed to the command; For example, if a command has 40 bits, we will break it into two packets. The first one uses the 26 data bits, and the mask 011010 (26) to indicate all the data bits are in use. Then, the second package would only use 14 of the 26 data bits available to reach the 40 bits the command has, and so the mask would be 001110 (14) to indicate that only 14 bits should be analyzed. To communicate between the components that the command is over, we send a void package 0b00000000000000000000000000000000 after the last package of the command. This occurs in two times in out product: first, when sending the command to the TAG, the NIOS II sends a void package to the Sender to indicate the command is over. Second, when receiving the response from the TAG, the Recevier sends a void package to the NIOS II to indicate that the command received is over.","title":"Packages and commands"},{"location":"hardware/#reader","text":"The READER, as shown in the diagram below, is the toplevel of our project, which contains the three main components. Here we will give an overview of each component, and a in depth analysis is present in the sections below. The first one is the NIOS II soft processor, where we programmed the tests that will be run on the TAG. Therefore, its responsible for generating the commands for communicating with the TAG, as well as interpreting the responses it receives, to assert whether the TAG passes or fails each test. The second component is the IP-Rfid, developed in VHDL, and is responsible for encoding and sending messages to the TAG, as well as decoding any responses and passing the through to the processor. Those two tasks have been separated into the sender and the receiver respectively. The last one is the Avalon Interface, is the connection between the NIOS II and the IP-Rfid, where the commands, generated in the programming language C, will be passed on to the VHDL sender, and responses will take the opposite path, going from the receiver to the processor.","title":"READER"},{"location":"hardware/#ip-rfid","text":"/main/fpga/RTL/rfid.vhd The developed peripheral can be split into two components, visualized in the diagram below. Those are the SENDER, in red, responsible for receiving the data from the NIOS II, encoding and forwarding them to the TAG; and the RECEIVER, in blue, responsible for receiving the data from the TAG, decoding and forwarding them to the NIOS II.","title":"IP-Rfid"},{"location":"hardware/#sender","text":"This component is responsible for encoding the commands generated by the processor, and send them to the TAG, respecting the rules of the EPC-GEN2 protocol, including the TARI, preamble and EOP. Its components are detailed below: FIFO The first component of the SENDER is the FIFO, a storage system that receives the assembled commands from the NIOS II and waits for the encoder to send the read request flag, signaling for the FIFO to send the oldest package. It is possible that the command to be sent to the TAG is composed of more than one package, so the FIFO serves as a storage system for packages already received from the processor until it signals that the entire command is ready for encoding. For this project, we opted to use the FIFO produced by Intel, which was obtained through the Quartus automatic generator, the main software used by the group for programming in VHDL language. It is possible to include several customizations before generating the code, and thus, the group defined that the FIFO would have, reset , write request , read request , FIFO full and FIFO empty flags to facilitate communication with other components of the project. Furthermore, it has a 32-bit word and a depth of 248 words. FIFO_FM0 FIFO-FM0 is a component created to separate the data encoding component from the signal-generator and the sender-controller, mapping the inputs: data to be encoded, write request for the FIFO, enable and tari to the other components, allowing for individual control of each component. Since the encoder does not need to obey the tari, it can operate independently, and much faster than the sender, since each bit can only be sent after the tari interval. Encoder The encoder is the main component of the sender, being responsible for encoding the packages received from the FIFO with FM0 band, as specified in the EPC-GEN2, as well as sending the encoded data to the TAG. for this purpose, a refined control of the time intervals is necessary to obey the TARI, also defined in the protocol as being between 6.25\u03bcs and 25\u03bcs. This component has two state machines that work simultaneously, one responsible for communicating with the FIFO and sending it to the TAG, while the other encodes the received data. The diagram below demonstrates the first state machine: Wait is the encoder's default, the state it remains in while it doesn't receive any new packages to encode; Start Send is the most complex state, where another state machine is present inside it, which is responsible for encoding the packages. Furthermore, it also expects to receive the correct TARI to send data to the TAG; Wait Send is a temporary state for when the data has been fully encoded, but due to the TARI limitations, has not been fully sent to the TAG yet. Once it finishes sending the data, it goes to the next state, Request Data ; Request Data happens after the data has been sent, and signals the FIFO to send more data. This state is very short, as its only duty is to send a flag to the FIFO, and immediately change to the Wait Request state; Wait Request can happen in two situations. First, if the Encoder is waiting for the next package from the FIFO, going back to the Start Send state once it is received. Second, it can happen once the FIFO sends the FIFO_empty signal to the Encoder. In this case, it will proceed to the Wait 1.6 TARI state; Wait 1.6 TARI is the formal completion of the command sent to the TAG, where a dummy 1 bit is sent, which will remain active for 1.6 TARI and then stop the communication; The next image demonstrates the other state machine present in the component, responsible for the encoding of the data. It was defined that it would always start in state S3 . FM0 encoding transforms each bit of information into two bits, in such a way so that a 1 becomes two bits of the same value (either 1 1 or 0 0 ), and a 0 becomes two bits of different values (either 1 0 or 0 1 ), where the signal always alternates when encoding a new bit. The change of state occurs after each bit has been sent and is defined by the value of the next bit. S1 encodes 1 into 1 1 ; S2 encodes 0 into 1 0 ; S3 encodes 0 into 0 1 ; S4 encodes 1 into 0 0 ; The previously defined dummy 1 acts as the EOP of a command passed to the TAG, however it also needs to be encoded, and is always followed by a 0 bit. This is shown in the image below. Signal Generator This component encompasses both the Preamble and Frame-sync functions, and receives flags to determine which one, if any, will be activated. The Frame-sync is responsible for defining and regulating the interval at which information is sent to the TAG, and sharing this interval to all other SENDER components, so that they can communicate within the correct time intervals. This period, named TARI, must be within the range defined in the protocol, and have a variation of less than 1% between each pulse. The Preamble is responsible for the first wave of information sent to the TAG for each new command, and it defines which TARI will be used throughout the next command. This component needs to be activated for every command that is sent to the TAG, except when more than one command is sent in sequence, without a response in between. In this case, the preamble informed will be valid for all subsequent commands, until a response is requested.","title":"SENDER"},{"location":"hardware/#receiver","text":"The RECEIVER is responsible for receiving the responses from the TAG, decode them, and notify the NIOS II processor that there was a response, as well as store each package of the response until the processor sends the read request flags to analyze them. In order for the received data to be interpreted, it is necessary that the information is decoded and grouped into packages, because it is possible the response is too large for the processor to receive all at once. The group decided to split the RECEIVER into three smaller components, shown and described below: Decoder Since the TAG also communicates back to the READER using FM0 encoding, a decoder component is needed to decode the received data, allowing it to be interpreted by the processor. This component was built in a similar way to the sender, though it is a simpler process, and only one state machine was needed. The diagram below demonstrates the state machine programmed for this purpose: Wait is the decoder's default, the state it remains in while it doesn't receive any new data to decode; Start Counter starts a time counter as soon as the decoder receives new data, in order to determine if the bit will change after 0.5 or 1.0 TARI, then passing to the next state. It is also possible for the bit to remain unchanged for more than 1.0 TARI, in which case it will go to the Pass 1.01 TARI state; Stop Counter sends 1 to the package constructor if the input signal has not changed, and 0 otherwise; Continue Counter is necessary because the stop counter always stop at 0.5 TARI, so it is activated if no bit change occurs; Pass 1.01 TARI is activated when the TAG sends the dummy 1 , which has a duration of 1.6 TARI, and checks if the times are in accordance with the protocol; Counter CS stops the counter and resets the decoder to its default state; ERROR is a state that can be activated by almost any other state, as they all check certain characteristics of that TAG that must comply with the protocol. If something is irregular, this status will be activated and will send an error message explaining what caused this to happen; Package Constructor This component is responsible for assembling the decoded bits into packages and storing them in the FIFO. It gathers the received bits until reaching the limit defined in the code, and then sending to the FIFO. If, however, the package constructor receives the EOP signal before completing the package, it will concatenate a mask with the current package to inform how many bits were filled. Furthermore, it will also extend the EOP flag to the FIFO and the processor, so that they know the RECEIVER has finished capturing and decoding the whole response command. Wait is the package constructor's default, the state it remains in while it doesn't receive any new data to store; New Bit happens when the decoder sends a decoded bit to the package constructor, which stores it in the current package being constructed; Inc Mask increases the package mask by 1 representing the new bit received; Max Mask checks whether the mask, and therefore the package, is full, preparing to send the package if it is; Send Package sends the current package to the FIFO, an intermediary step before going to the NIOS II processor; Check EOP checks if the EOP flag is high, and changes state based on the current packet. If it is empty, goes to the Send void state, if not goes to the Send Package ; Clear clears the current package before starting a new one; Send Void send to the FIFO an empty package - 0b00000000000000000000000000000000 FIFO The FIFO in the RECEIVER is the same as the one in the SENDER and serves similar purpose, however with inverted direction. This FIFO stores packages leaving the package constructor until it receives the EOP flag, which also signals the NIOS II that the command is ready to be requested. After this, the FIFO sends the packages to the processor one at a time, each time it receives a read request flag. FPGA Intel. https://www.intel.com.br/content/www/br/pt/products/programmable.html Accessed on: 23/08/2021 \u21a9 Nios II Custom Instruction User Guide. https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/ug/ug_nios2_custom_instruction.pdf Acessed on: 23/08/2021. \u21a9","title":"RECEIVER"},{"location":"software/","text":"Software \u00b6 Below is an axplanation of the software code of our project, the NIOS II soft processor. NIOS II \u00b6 The NIOS II is a soft processor, which means that, unlike discrete processors, such as those in conventional computers, its peripherals and addressing can be reconfigured on demand. This enables the development of a specialized and efficient processor, reducing the costs and time of producing a prototype since it is dynamically generated inside the FPGA without the need to produce a new processor. Communication between the NIOS II and the peripheral IP-Rfid is done via the Avalon data bus, which is a memory-mapped peripheral. The addressing works as in a common memory, having write, read, and address signals, as well as the input and output vectors of this bus. The NIOS II function is to write the commands and tests in the register banks present in the IP peripheral, so that it can communicate with the TAG. This processor can be viewed as the conductor and all other components as the orchestra, as it is responsible for enabling, configuring, reading, and writing data from the Avalon memory to the IP-Rfid. Throughout this project, the group breaks commands into packages for ease of use. Details on how this is done can be found here File Hierarchy \u00b6 All necessary C and header filesare located in the project\u2019s fpga/software/rfid_test folder. The top entity of the entire processor including all the required configuration generics is main.c and all other relevant files are inside the helpers folder. main.c - NIOS II soft processor top entity \u2502 \u251ccrc.c - Cyclic Redundance Check file \u2502 \u2514/helpers - Holds all complimentary C files \u2502 \u251c/functions - Holds all functions that dictate how the components act \u2502\u2502 \u2502\u251csender.c - Holds all functions that dictate how the Sender acts \u2502\u251creceiver.c - Holds all functions that dictate how the Receiver acts \u2502\u2514rfid.c - Holds all functions about tari, commands and packages \u2502 \u2514/commands - Holds all the EPC-GEN2 mandatory commands \u2502 \u251cack.c - Mandatory command ack \u251ckill.c - Mandatory command kill \u251clock.c - Mandatory command lock \u251cnak.c - Mandatory command nak \u251cquery.c - Mandatory command query \u251cquery_adjust.c - Mandatory command query_adjust \u251cquery_rep.c - Mandatory command query_rep \u251cread.c - Mandatory command read \u251creq_rn.c - Mandatory command req_rn \u251crn16.c - Mandatory command rn16 \u251crn_crc.c - Mandatory command rn_crc \u251cselect.c - Mandatory command select \u251cwrite.c - Mandatory command write Additional information on the EPC-GEN2 protocol and mandatory commands (as well as the other command types) can be found here here Starting Variables \u00b6 Register Status //READ ONLY define BASE_IS_FIFO_FULL ( 1 << 0 ) define MASK_EMPTY_RECEIVER ( 1 << 13 ) BASE_IS_FIFO_FULL - Indicates the necessary shift for the is_FIFO_full flag MASK_EMPTY_RECEIVER - Indicates the necessary shift for the is_receiver_empty flag Register Settings //READ/WRITE define BASE_REG_SET ( 0 ) define MASK_RST ( 1 << 0 ) define MASK_EN ( 1 << 1 ) define MASK_RST_RECEIVER ( 1 << 10 ) define MASK_EN_RECEIVER ( 1 << 4 ) define MASK_CLR_FIFO ( 1 << 2 ) define MASK_LOOPBACK ( 1 << 8 ) define MASK_CLR_FINISHED ( 1 << 1 ) define SENDER_HAS_GEN ( 0 << 5 ) define SENDER_ENABLE_CTRL ( 1 << 6 ) define SENDER_IS_PREAMBLE ( 0 << 7 ) define MASK_READ_REQ ( 1 << 12 ) define MASK_FINISH_SEND ( 1 << 3 ) BASE_REG_SET - Memory address for the REGISTER_SETTINGS MASK_RST - Indicates the necessary shift for the sender_reset flag MASK_EN - Indicates the necessary shift for the sender_enable flag MASK_RST_RECEIVER - Indicates the necessary shift for the receiver_reset flag MASK_EN_RECEIVER - Indicates the necessary shift for the receiver_enable flag MASK_CLR_FIFO - Indicates the necessary shift for the sender_clear_FIFO flag MASK_LOOPBACK - Indicates the necessary shift for the RFID_loopback flag MASK_CLR_FINISHED - Indicates the necessary shift for the sender_clear_finished flag SENDER_HAS_GEN - Indicates the necessary shift for the sender_has_generator flag SENDER_ENABLE_CTRL - Indicates the necessary shift for the sender_enable_controller flag SENDER_IS_PREAMBLE - Indicates the necessary shift for the sender_is_preamble flag MASK_READ_REQ - Indicates the necessary shift for the receiver_read_request flag MASK_FINISH_SEND - Indicates the necessary shift for the mask_finish_send flag RFID- Addresses define BASE_REG_TARI ( 1 ) define BASE_REG_FIFO ( 2 ) define BASE_REG_TARI_101 ( 3 ) define BASE_REG_TARI_099 ( 4 ) define BASE_REG_TARI_1616 ( 5 ) define BASE_REG_TARI_1584 ( 6 ) define BASE_REG_PW ( 7 ) define BASE_REG_DELIMITER ( 8 ) define BASE_REG_RTCAL ( 9 ) define BASE_REG_TRCAL ( 10 ) define BASE_REG_STATUS ( 3 ) define BASE_RECEIVER_DATA ( 4 ) define BASE_SENDER_USEDW ( 5 ) define BASE_RECEIVER_USEDW ( 6 ) define BASE_ID ( 7 ) BASE_REG_TARI - R/W - address of the tari BASE_REG_FIFO - R/W - address of FIFO R/W BASE_REG_TARI_101 - W - address of tari_101 BASE_REG_TARI_099 - W - address of tari_099 BASE_REG_TARI_1616 - W - address of tari_1616 BASE_REG_TARI_1584 - W - address of tari_1584 BASE_REG_PW - W - address of pw BASE_REG_DELIMITER - W - address of delimiter BASE_REG_RTCAL - W - address of receiver transmitter callibration BASE_REG_TRCAL - W - address of transmitter receiver callibrtation BASE_REG_STATUS - R - address of REGISTER_STATUS BASE_RECEIVER_DATA - R - address of receiver data BASE_SENDER_USEDW - R - address of sender_FIFO_actual_size BASE_RECEIVER_USEDW - R - address of receiver_FIFO_actual_size BASE_ID - R - address of IP_rfid RFID- Command specifications // package defines define data_mask_size ( 6 ) define data_package_size ( 26 ) define eop ( 0b00000000000000000000000000000000 ) define bits6 ( 0b111111 ) define bits26 ( 0b11111111111111111111111111 ) define bits32 ( 0b11111111111111111111111111111111 ) data_mask_size - defines the number of bits reserved for the mask data_package_size - defines the number of bits reserved for the data eop - defines the END_OF_PACKAGE format bits6 - mask for full package mask bits26 - mask for full package data bits32 - mask for full package RFID- Start of Communication Values int tari = 0x1f4 ; int tari_101 = 0x1f9 ; int tari_099 = 0x1EF ; int tari_1616 = 0x328 ; int tari_1584 = 0x318 ; int pw = 0xFA ; int delimiter = 0x271 ; int RTcal = 0x546 ; int TRcal = 0x546 ; tari - tari time parameter tari_101 - 1% above tari limit tari_099 - 1% below tari limit tari_1616 - 1% above 1.6 tari limit tari_1584 - 1% below 1.6 tari limit pw - pw parameter delimiter - Delimiter parameter RTcal - Receiver transmitter callibration parameter TRcal - Transmitter receiver callibration parameter Functions \u00b6 RFID functions void rfid_set_loopback () void rfid_set_tari ( int tari_value ) void rfid_set_tari_boundaries ( int tari_101 , int tari_099 , int tari_1616 , int tari_1584 , int pw , int delimiter , int RTcal , int TRcal ) int rfid_create_mask_from_value ( int value ) int rfid_check_command ( int * packages , int quant_packages , int command_size ) int rfid_get_ip_id () void rfid_set_loopback - Connects Tx on Rx creating a loop, used for testing the reader void rfid_set_tari - Sets the tari value on the IP rfid void rfid_set_tari_boundaries - Sets the tari boundaries on the IP rfid int rfid_create_mask_from_value - Generates the package mask based on the package received int rfid_check_command - Checks if the received command is valid and present on the EPC-GEN2 protocol int rfid_get_ip_id - Checks the currend address for the IP_rfid SENDER functions int sender_check_usedw () int sender_check_fifo_full () void sender_enable () void sender_send_package ( int package ) void sender_send_end_of_package () void sender_start_ctrl () void sender_write_clr_finished_sending () int sender_read_finished_send () int sender_get_command_ints_size ( int size_of_command ) void sender_add_mask ( int n , int command_vector_masked [ n ], unsigned long long result_data , unsigned int result_data_size ) void sender_has_gen ( int usesPreorFrameSync ) void sender_is_preamble () void sender_send_command ( command * command_ptr ) sender_check_usedw - Access the address that indicates how many packages are in the sender FIFO sender_check_fifo_full - Access REG_STATUS to verify wether the FIFO is full or not sender_enable - Access REG_SET to activate the peripheral Sender on the IP rfid sender_send_package - Writes the package on the FIFO address sender_send_end_of_package - Writes the EOP on the FIFO address sender_start_ctrl - Access REG_SET to activate the sender controller with a pulse sender_write_clr_finished_sending - Access REG_SET to clear the finished_sending flag with a pulse sender_read_finished_send - Access RES_STATUS to check wether the package has been sent or not sender_get_command_ints_size - Check the size of the command and calculates the size of each smaller package sender_add_mask - Divides the command into smaller packages if needed and generates a mask based on the current package data size sender_has_gen - Access REG_SET to define wether the generator should be activated sender_is_preamble - If the generator is activated, defines if the generator is a preamble or a framesync sender_send_command - Runs the all the functions related to the command, going through all the steps necessary to split in packages, add the masks, send and clear the flag registers in the end RECEIVER functions void receiver_enable () int receiver_check_usedw () int receiver_request_package () int receiver_empty () void receiver_rdreq () void receiver_get_package ( int * command_vector , int quant_packages , int * command_size , int * quant_packages_received ) receiver_enable - Access REG_SET to activate the peripheral Receiver on the IP rfid receiver_check_usedw - Access the address that indicates how many packages are in the receiver FIFO receiver_request_package - Access BASE_RECEIVER_DATA to read the received package receiver_empty - Access REG_SET to check wether the receiver FIFO is empty or not receiver_rdreq - Access REG_SET to set the read_request flag with a pulse receiver_get_package - Separates the package from receiver_request_package into data and mask","title":"Software"},{"location":"software/#software","text":"Below is an axplanation of the software code of our project, the NIOS II soft processor.","title":"Software"},{"location":"software/#nios-ii","text":"The NIOS II is a soft processor, which means that, unlike discrete processors, such as those in conventional computers, its peripherals and addressing can be reconfigured on demand. This enables the development of a specialized and efficient processor, reducing the costs and time of producing a prototype since it is dynamically generated inside the FPGA without the need to produce a new processor. Communication between the NIOS II and the peripheral IP-Rfid is done via the Avalon data bus, which is a memory-mapped peripheral. The addressing works as in a common memory, having write, read, and address signals, as well as the input and output vectors of this bus. The NIOS II function is to write the commands and tests in the register banks present in the IP peripheral, so that it can communicate with the TAG. This processor can be viewed as the conductor and all other components as the orchestra, as it is responsible for enabling, configuring, reading, and writing data from the Avalon memory to the IP-Rfid. Throughout this project, the group breaks commands into packages for ease of use. Details on how this is done can be found here","title":"NIOS II"},{"location":"software/#file-hierarchy","text":"All necessary C and header filesare located in the project\u2019s fpga/software/rfid_test folder. The top entity of the entire processor including all the required configuration generics is main.c and all other relevant files are inside the helpers folder. main.c - NIOS II soft processor top entity \u2502 \u251ccrc.c - Cyclic Redundance Check file \u2502 \u2514/helpers - Holds all complimentary C files \u2502 \u251c/functions - Holds all functions that dictate how the components act \u2502\u2502 \u2502\u251csender.c - Holds all functions that dictate how the Sender acts \u2502\u251creceiver.c - Holds all functions that dictate how the Receiver acts \u2502\u2514rfid.c - Holds all functions about tari, commands and packages \u2502 \u2514/commands - Holds all the EPC-GEN2 mandatory commands \u2502 \u251cack.c - Mandatory command ack \u251ckill.c - Mandatory command kill \u251clock.c - Mandatory command lock \u251cnak.c - Mandatory command nak \u251cquery.c - Mandatory command query \u251cquery_adjust.c - Mandatory command query_adjust \u251cquery_rep.c - Mandatory command query_rep \u251cread.c - Mandatory command read \u251creq_rn.c - Mandatory command req_rn \u251crn16.c - Mandatory command rn16 \u251crn_crc.c - Mandatory command rn_crc \u251cselect.c - Mandatory command select \u251cwrite.c - Mandatory command write Additional information on the EPC-GEN2 protocol and mandatory commands (as well as the other command types) can be found here here","title":"File Hierarchy"},{"location":"software/#starting-variables","text":"Register Status //READ ONLY define BASE_IS_FIFO_FULL ( 1 << 0 ) define MASK_EMPTY_RECEIVER ( 1 << 13 ) BASE_IS_FIFO_FULL - Indicates the necessary shift for the is_FIFO_full flag MASK_EMPTY_RECEIVER - Indicates the necessary shift for the is_receiver_empty flag Register Settings //READ/WRITE define BASE_REG_SET ( 0 ) define MASK_RST ( 1 << 0 ) define MASK_EN ( 1 << 1 ) define MASK_RST_RECEIVER ( 1 << 10 ) define MASK_EN_RECEIVER ( 1 << 4 ) define MASK_CLR_FIFO ( 1 << 2 ) define MASK_LOOPBACK ( 1 << 8 ) define MASK_CLR_FINISHED ( 1 << 1 ) define SENDER_HAS_GEN ( 0 << 5 ) define SENDER_ENABLE_CTRL ( 1 << 6 ) define SENDER_IS_PREAMBLE ( 0 << 7 ) define MASK_READ_REQ ( 1 << 12 ) define MASK_FINISH_SEND ( 1 << 3 ) BASE_REG_SET - Memory address for the REGISTER_SETTINGS MASK_RST - Indicates the necessary shift for the sender_reset flag MASK_EN - Indicates the necessary shift for the sender_enable flag MASK_RST_RECEIVER - Indicates the necessary shift for the receiver_reset flag MASK_EN_RECEIVER - Indicates the necessary shift for the receiver_enable flag MASK_CLR_FIFO - Indicates the necessary shift for the sender_clear_FIFO flag MASK_LOOPBACK - Indicates the necessary shift for the RFID_loopback flag MASK_CLR_FINISHED - Indicates the necessary shift for the sender_clear_finished flag SENDER_HAS_GEN - Indicates the necessary shift for the sender_has_generator flag SENDER_ENABLE_CTRL - Indicates the necessary shift for the sender_enable_controller flag SENDER_IS_PREAMBLE - Indicates the necessary shift for the sender_is_preamble flag MASK_READ_REQ - Indicates the necessary shift for the receiver_read_request flag MASK_FINISH_SEND - Indicates the necessary shift for the mask_finish_send flag RFID- Addresses define BASE_REG_TARI ( 1 ) define BASE_REG_FIFO ( 2 ) define BASE_REG_TARI_101 ( 3 ) define BASE_REG_TARI_099 ( 4 ) define BASE_REG_TARI_1616 ( 5 ) define BASE_REG_TARI_1584 ( 6 ) define BASE_REG_PW ( 7 ) define BASE_REG_DELIMITER ( 8 ) define BASE_REG_RTCAL ( 9 ) define BASE_REG_TRCAL ( 10 ) define BASE_REG_STATUS ( 3 ) define BASE_RECEIVER_DATA ( 4 ) define BASE_SENDER_USEDW ( 5 ) define BASE_RECEIVER_USEDW ( 6 ) define BASE_ID ( 7 ) BASE_REG_TARI - R/W - address of the tari BASE_REG_FIFO - R/W - address of FIFO R/W BASE_REG_TARI_101 - W - address of tari_101 BASE_REG_TARI_099 - W - address of tari_099 BASE_REG_TARI_1616 - W - address of tari_1616 BASE_REG_TARI_1584 - W - address of tari_1584 BASE_REG_PW - W - address of pw BASE_REG_DELIMITER - W - address of delimiter BASE_REG_RTCAL - W - address of receiver transmitter callibration BASE_REG_TRCAL - W - address of transmitter receiver callibrtation BASE_REG_STATUS - R - address of REGISTER_STATUS BASE_RECEIVER_DATA - R - address of receiver data BASE_SENDER_USEDW - R - address of sender_FIFO_actual_size BASE_RECEIVER_USEDW - R - address of receiver_FIFO_actual_size BASE_ID - R - address of IP_rfid RFID- Command specifications // package defines define data_mask_size ( 6 ) define data_package_size ( 26 ) define eop ( 0b00000000000000000000000000000000 ) define bits6 ( 0b111111 ) define bits26 ( 0b11111111111111111111111111 ) define bits32 ( 0b11111111111111111111111111111111 ) data_mask_size - defines the number of bits reserved for the mask data_package_size - defines the number of bits reserved for the data eop - defines the END_OF_PACKAGE format bits6 - mask for full package mask bits26 - mask for full package data bits32 - mask for full package RFID- Start of Communication Values int tari = 0x1f4 ; int tari_101 = 0x1f9 ; int tari_099 = 0x1EF ; int tari_1616 = 0x328 ; int tari_1584 = 0x318 ; int pw = 0xFA ; int delimiter = 0x271 ; int RTcal = 0x546 ; int TRcal = 0x546 ; tari - tari time parameter tari_101 - 1% above tari limit tari_099 - 1% below tari limit tari_1616 - 1% above 1.6 tari limit tari_1584 - 1% below 1.6 tari limit pw - pw parameter delimiter - Delimiter parameter RTcal - Receiver transmitter callibration parameter TRcal - Transmitter receiver callibration parameter","title":"Starting Variables"},{"location":"software/#functions","text":"RFID functions void rfid_set_loopback () void rfid_set_tari ( int tari_value ) void rfid_set_tari_boundaries ( int tari_101 , int tari_099 , int tari_1616 , int tari_1584 , int pw , int delimiter , int RTcal , int TRcal ) int rfid_create_mask_from_value ( int value ) int rfid_check_command ( int * packages , int quant_packages , int command_size ) int rfid_get_ip_id () void rfid_set_loopback - Connects Tx on Rx creating a loop, used for testing the reader void rfid_set_tari - Sets the tari value on the IP rfid void rfid_set_tari_boundaries - Sets the tari boundaries on the IP rfid int rfid_create_mask_from_value - Generates the package mask based on the package received int rfid_check_command - Checks if the received command is valid and present on the EPC-GEN2 protocol int rfid_get_ip_id - Checks the currend address for the IP_rfid SENDER functions int sender_check_usedw () int sender_check_fifo_full () void sender_enable () void sender_send_package ( int package ) void sender_send_end_of_package () void sender_start_ctrl () void sender_write_clr_finished_sending () int sender_read_finished_send () int sender_get_command_ints_size ( int size_of_command ) void sender_add_mask ( int n , int command_vector_masked [ n ], unsigned long long result_data , unsigned int result_data_size ) void sender_has_gen ( int usesPreorFrameSync ) void sender_is_preamble () void sender_send_command ( command * command_ptr ) sender_check_usedw - Access the address that indicates how many packages are in the sender FIFO sender_check_fifo_full - Access REG_STATUS to verify wether the FIFO is full or not sender_enable - Access REG_SET to activate the peripheral Sender on the IP rfid sender_send_package - Writes the package on the FIFO address sender_send_end_of_package - Writes the EOP on the FIFO address sender_start_ctrl - Access REG_SET to activate the sender controller with a pulse sender_write_clr_finished_sending - Access REG_SET to clear the finished_sending flag with a pulse sender_read_finished_send - Access RES_STATUS to check wether the package has been sent or not sender_get_command_ints_size - Check the size of the command and calculates the size of each smaller package sender_add_mask - Divides the command into smaller packages if needed and generates a mask based on the current package data size sender_has_gen - Access REG_SET to define wether the generator should be activated sender_is_preamble - If the generator is activated, defines if the generator is a preamble or a framesync sender_send_command - Runs the all the functions related to the command, going through all the steps necessary to split in packages, add the masks, send and clear the flag registers in the end RECEIVER functions void receiver_enable () int receiver_check_usedw () int receiver_request_package () int receiver_empty () void receiver_rdreq () void receiver_get_package ( int * command_vector , int quant_packages , int * command_size , int * quant_packages_received ) receiver_enable - Access REG_SET to activate the peripheral Receiver on the IP rfid receiver_check_usedw - Access the address that indicates how many packages are in the receiver FIFO receiver_request_package - Access BASE_RECEIVER_DATA to read the received package receiver_empty - Access REG_SET to check wether the receiver FIFO is empty or not receiver_rdreq - Access REG_SET to set the read_request flag with a pulse receiver_get_package - Separates the package from receiver_request_package into data and mask","title":"Functions"}]}